diff --git a/gypfiles/landmine_utils.py b/gypfiles/landmine_utils.py
index cb34991..be0a70e 100644
--- a/gypfiles/landmine_utils.py
+++ b/gypfiles/landmine_utils.py
@@ -33,7 +33,7 @@ def IsWindows():
 
 @memoize()
 def IsLinux():
-  return sys.platform.startswith(('linux', 'freebsd'))
+  return sys.platform.startswith(('linux', 'freebsd', 'openbsd'))
 
 
 @memoize()
diff --git a/src/base/debug/stack_trace_posix.cc b/src/base/debug/stack_trace_posix.cc
index 87c0a73..2e1545e 100644
--- a/src/base/debug/stack_trace_posix.cc
+++ b/src/base/debug/stack_trace_posix.cc
@@ -29,6 +29,12 @@
 #define HAVE_EXECINFO_H 1
 #endif
 
+// backtrace support is broken in OpenBSD
+#if defined(__OpenBSD__)
+#undef HAVE_EXECINFO_H
+#define HAVE_EXECINFO_H 0
+#endif
+
 #if HAVE_EXECINFO_H
 #include <cxxabi.h>
 #include <execinfo.h>
@@ -77,11 +83,11 @@ const char kSymbolCharacters[] =
 // "out/Debug/base_unittests(_ZN10StackTraceC1Ev+0x20) [0x817778c]"
 // =>
 // "out/Debug/base_unittests(StackTrace::StackTrace()+0x20) [0x817778c]"
+#if HAVE_EXECINFO_H
 void DemangleSymbols(std::string* text) {
   // Note: code in this function is NOT async-signal safe (std::string uses
   // malloc internally).
 
-#if HAVE_EXECINFO_H
 
   std::string::size_type search_from = 0;
   while (search_from < text->size()) {
@@ -118,8 +124,8 @@ void DemangleSymbols(std::string* text) {
     }
   }
 
-#endif  // HAVE_EXECINFO_H
 }
+#endif  // HAVE_EXECINFO_H
 
 class BacktraceOutputHandler {
  public:
@@ -129,6 +135,7 @@ class BacktraceOutputHandler {
   virtual ~BacktraceOutputHandler() {}
 };
 
+#if HAVE_EXECINFO_H
 void OutputPointer(void* pointer, BacktraceOutputHandler* handler) {
   // This should be more than enough to store a 64-bit number in hex:
   // 16 hex digits + 1 for null-terminator.
@@ -138,6 +145,7 @@ void OutputPointer(void* pointer, BacktraceOutputHandler* handler) {
                    12);
   handler->HandleOutput(buf);
 }
+#endif  // HAVE_EXECINFO_H
 
 #if HAVE_EXECINFO_H
 void ProcessBacktrace(void* const* trace, size_t size,
diff --git a/src/base/platform/platform-posix.cc b/src/base/platform/platform-posix.cc
index 3f4165d..7d491a7 100644
--- a/src/base/platform/platform-posix.cc
+++ b/src/base/platform/platform-posix.cc
@@ -333,6 +333,8 @@ int OS::GetCurrentThreadId() {
   return static_cast<int>(thread_self());
 #elif V8_OS_SOLARIS
   return static_cast<int>(pthread_self());
+#elif V8_OS_OPENBSD
+  return reinterpret_cast<uint64_t>(pthread_self());
 #else
   return static_cast<int>(reinterpret_cast<intptr_t>(pthread_self()));
 #endif
diff --git a/src/d8.cc b/src/d8.cc
index a8af9de..6a5a425 100644
--- a/src/d8.cc
+++ b/src/d8.cc
@@ -2,6 +2,9 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include <stdio.h>
+#include <stdint.h>
+#include <libkruntime.h>
 
 // Defined when linking against shared lib on Windows.
 #if defined(USING_V8_SHARED) && !defined(V8_SHARED)
@@ -67,6 +70,24 @@
 #define CHECK(condition) assert(condition)
 #endif
 
+/*
+ * Converts a V8 double to a C int.
+ *
+ * Used only for use as mdata indicies and CPU core indicies, which are small
+ * numbers.
+ */
+#define DOUBLE_ARG_TO_CINT_CHECKED(ARGS_IDX, TO) \
+    if (!args[ARGS_IDX]->IsNumber()) { \
+        Throw(args.GetIsolate(), "Invalid argument"); \
+    } \
+    int TO = (int) Local<Number>::Cast(args[ARGS_IDX])->Value();
+
+#define CHECK_NUM_ARGS(ARGS, NUM) \
+  if (ARGS.Length() != NUM) { \
+    Throw(ARGS.GetIsolate(), "Wrong number of arguments"); \
+    return; \
+  }
+
 namespace v8 {
 
 namespace {
@@ -770,6 +791,60 @@ void Shell::Print(const v8::FunctionCallbackInfo<v8::Value>& args) {
   fflush(stdout);
 }
 
+void Shell::PrintErr(const v8::FunctionCallbackInfo<v8::Value>& args) {
+  WriteErr(args);
+  fprintf(stderr, "\n");
+  fflush(stderr);
+}
+
+void Shell::KrunGetWallclock(const v8::FunctionCallbackInfo<v8::Value>& args) {
+    CHECK_NUM_ARGS(args, 1);
+    DOUBLE_ARG_TO_CINT_CHECKED(0, mdata_index);
+    args.GetReturnValue().Set(krun_get_wallclock(mdata_index));
+}
+
+void Shell::KrunGetCoreCyclesDouble(const v8::FunctionCallbackInfo<v8::Value>& args) {
+    CHECK_NUM_ARGS(args, 2);
+    DOUBLE_ARG_TO_CINT_CHECKED(0, mdata_index);
+    DOUBLE_ARG_TO_CINT_CHECKED(1, core);
+    args.GetReturnValue().Set(krun_get_core_cycles_double(mdata_index, core));
+}
+
+void Shell::KrunMeasure(const v8::FunctionCallbackInfo<v8::Value>& args) {
+    CHECK_NUM_ARGS(args, 1);
+    DOUBLE_ARG_TO_CINT_CHECKED(0, mdata_index);
+    krun_measure(mdata_index);
+}
+
+void Shell::KrunClockGettimeMonotonic(const v8::FunctionCallbackInfo<v8::Value>& args) {
+    args.GetReturnValue().Set(krun_clock_gettime_monotonic());
+}
+
+void Shell::KrunGetNumCores(const v8::FunctionCallbackInfo<v8::Value>& args) {
+    args.GetReturnValue().Set(krun_get_num_cores());
+}
+
+void Shell::KrunGetAperfDouble(const v8::FunctionCallbackInfo<v8::Value>& args) {
+    CHECK_NUM_ARGS(args, 2);
+    DOUBLE_ARG_TO_CINT_CHECKED(0, mdata_index);
+    DOUBLE_ARG_TO_CINT_CHECKED(1, core);
+    args.GetReturnValue().Set(krun_get_aperf_double(mdata_index, core));
+}
+
+void Shell::KrunGetMperfDouble(const v8::FunctionCallbackInfo<v8::Value>& args) {
+    CHECK_NUM_ARGS(args, 2);
+    DOUBLE_ARG_TO_CINT_CHECKED(0, mdata_index);
+    DOUBLE_ARG_TO_CINT_CHECKED(1, core);
+    args.GetReturnValue().Set(krun_get_mperf_double(mdata_index, core));
+}
+
+void Shell::KrunInit(const v8::FunctionCallbackInfo<v8::Value>& args) {
+    krun_init();
+}
+
+void Shell::KrunDone(const v8::FunctionCallbackInfo<v8::Value>& args) {
+    krun_done();
+}
 
 void Shell::Write(const v8::FunctionCallbackInfo<v8::Value>& args) {
   for (int i = 0; i < args.Length(); i++) {
@@ -801,6 +876,33 @@ void Shell::Write(const v8::FunctionCallbackInfo<v8::Value>& args) {
   }
 }
 
+void Shell::WriteErr(const v8::FunctionCallbackInfo<v8::Value>& args) {
+  Isolate* isolate = args.GetIsolate();
+  for (int j = 0; j < args.Length(); j++) {
+    HandleScope handle_scope(args.GetIsolate());
+    if (j != 0) {
+      printf(" ");
+    }
+
+    // Explicitly catch potential exceptions in toString().
+    v8::TryCatch try_catch(isolate);
+    Local<String> str_obj;
+    if (!args[j]
+             ->ToString(args.GetIsolate()->GetCurrentContext())
+             .ToLocal(&str_obj)) {
+      try_catch.ReThrow();
+      return;
+    }
+
+    v8::String::Utf8Value str(str_obj);
+    int n = static_cast<int>(fwrite(*str, sizeof(**str), str.length(), stderr));
+    if (n != str.length()) {
+      printf("Error in fwrite\n");
+      Exit(1);
+    }
+  }
+}
+
 
 void Shell::Read(const v8::FunctionCallbackInfo<v8::Value>& args) {
   String::Utf8Value file(args[0]);
@@ -1227,10 +1329,54 @@ Local<ObjectTemplate> Shell::CreateGlobalTemplate(Isolate* isolate) {
           .ToLocalChecked(),
       FunctionTemplate::New(isolate, Print));
   global_template->Set(
+      String::NewFromUtf8(isolate, "print_err", NewStringType::kNormal)
+          .ToLocalChecked(),
+      FunctionTemplate::New(isolate, PrintErr));
+  global_template->Set(
+      String::NewFromUtf8(isolate, "krun_get_wallclock", NewStringType::kNormal)
+          .ToLocalChecked(),
+      FunctionTemplate::New(isolate, KrunGetWallclock));
+  global_template->Set(
+      String::NewFromUtf8(isolate, "krun_get_core_cycles_double", NewStringType::kNormal)
+          .ToLocalChecked(),
+      FunctionTemplate::New(isolate, KrunGetCoreCyclesDouble));
+  global_template->Set(
+      String::NewFromUtf8(isolate, "krun_get_aperf_double", NewStringType::kNormal)
+          .ToLocalChecked(),
+      FunctionTemplate::New(isolate, KrunGetAperfDouble));
+  global_template->Set(
+      String::NewFromUtf8(isolate, "krun_get_mperf_double", NewStringType::kNormal)
+          .ToLocalChecked(),
+      FunctionTemplate::New(isolate, KrunGetMperfDouble));
+  global_template->Set(
+      String::NewFromUtf8(isolate, "krun_init", NewStringType::kNormal)
+          .ToLocalChecked(),
+      FunctionTemplate::New(isolate, KrunInit));
+  global_template->Set(
+      String::NewFromUtf8(isolate, "krun_done", NewStringType::kNormal)
+          .ToLocalChecked(),
+      FunctionTemplate::New(isolate, KrunDone));
+  global_template->Set(
+      String::NewFromUtf8(isolate, "krun_measure", NewStringType::kNormal)
+          .ToLocalChecked(),
+      FunctionTemplate::New(isolate, KrunMeasure));
+  global_template->Set(
+      String::NewFromUtf8(isolate, "krun_clock_gettime_monotonic", NewStringType::kNormal)
+          .ToLocalChecked(),
+      FunctionTemplate::New(isolate, KrunClockGettimeMonotonic));
+  global_template->Set(
+      String::NewFromUtf8(isolate, "krun_get_num_cores", NewStringType::kNormal)
+          .ToLocalChecked(),
+      FunctionTemplate::New(isolate, KrunGetNumCores));
+  global_template->Set(
       String::NewFromUtf8(isolate, "write", NewStringType::kNormal)
           .ToLocalChecked(),
       FunctionTemplate::New(isolate, Write));
   global_template->Set(
+      String::NewFromUtf8(isolate, "write_err", NewStringType::kNormal)
+          .ToLocalChecked(),
+      FunctionTemplate::New(isolate, WriteErr));
+  global_template->Set(
       String::NewFromUtf8(isolate, "read", NewStringType::kNormal)
           .ToLocalChecked(),
       FunctionTemplate::New(isolate, Read));
diff --git a/src/d8.gyp b/src/d8.gyp
index cc65a5b..4099d76 100644
--- a/src/d8.gyp
+++ b/src/d8.gyp
@@ -46,6 +46,17 @@
         '..',
         '<(DEPTH)',
       ],
+      'link_settings': {
+        'libraries+': [
+          '-lkruntime',
+	],
+        'ldflags+': [
+          '-L<!(echo $LIBKRUN_DIR)',
+        ],
+      },
+      'cflags_cc+': [
+	'-I<!(echo $LIBKRUN_DIR)',
+      ],
       'sources': [
         'd8.h',
         'd8.cc',
diff --git a/src/d8.h b/src/d8.h
index 0e365a5..9642f32 100644
--- a/src/d8.h
+++ b/src/d8.h
@@ -391,7 +391,18 @@ class Shell : public i::AllStatic {
                              const  PropertyCallbackInfo<void>& info);
 
   static void Print(const v8::FunctionCallbackInfo<v8::Value>& args);
+  static void PrintErr(const v8::FunctionCallbackInfo<v8::Value>& args);
+  static void KrunGetWallclock(const v8::FunctionCallbackInfo<v8::Value>& args);
+  static void KrunGetCoreCyclesDouble(const v8::FunctionCallbackInfo<v8::Value>& args);
+  static void KrunGetAperfDouble(const v8::FunctionCallbackInfo<v8::Value>& args);
+  static void KrunGetMperfDouble(const v8::FunctionCallbackInfo<v8::Value>& args);
+  static void KrunInit(const v8::FunctionCallbackInfo<v8::Value>& args);
+  static void KrunDone(const v8::FunctionCallbackInfo<v8::Value>& args);
+  static void KrunMeasure(const v8::FunctionCallbackInfo<v8::Value>& args);
+  static void KrunClockGettimeMonotonic(const v8::FunctionCallbackInfo<v8::Value>& args);
+  static void KrunGetNumCores(const v8::FunctionCallbackInfo<v8::Value>& args);
   static void Write(const v8::FunctionCallbackInfo<v8::Value>& args);
+  static void WriteErr(const v8::FunctionCallbackInfo<v8::Value>& args);
   static void QuitOnce(v8::FunctionCallbackInfo<v8::Value>* args);
   static void Quit(const v8::FunctionCallbackInfo<v8::Value>& args);
   static void Version(const v8::FunctionCallbackInfo<v8::Value>& args);
diff --git a/src/v8.gyp b/src/v8.gyp
index 1adb2fe..ba83ace 100644
--- a/src/v8.gyp
+++ b/src/v8.gyp
@@ -1920,8 +1920,10 @@
             'link_settings': {
               'libraries': [
                 '-L/usr/local/lib -lexecinfo',
+                '-Wl,-z,wxneeded',
             ]},
             'sources': [
+              'base/debug/stack_trace_posix.cc',
               'base/platform/platform-openbsd.cc',
               'base/platform/platform-posix.cc'
             ],
