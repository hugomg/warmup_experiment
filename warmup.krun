import os
import sys
import platform
from krun.vm_defs import (PythonVMDef, LuaVMDef, JavaVMDef, GraalVMDef,
                          PHPVMDef, JRubyTruffleVMDef, V8VMDef, NativeCodeVMDef,
                          find_internal_jvmci_java_home,
                          find_internal_jvmci_java_bin, PyPyVMDef)
from krun import EntryPoint

# Who to mail
MAIL_TO = []

DIR = os.getcwd()
JKRUNTIME_DIR = os.path.join(DIR, "krun", "libkruntime", "")

if sys.platform.startswith("linux"):
    JDK8_HOME = os.path.join(DIR, "work/openjdk/build/linux-x86_64-normal-server-release/images/j2sdk-image/")
elif sys.platform.startswith("openbsd"):
    JDK8_HOME = os.path.join(DIR, "work/openjdk/build/bsd-x86_64-normal-server-release/images/j2sdk-image/")
else:
    raise NotImplementedError("unknown platform")

JDK8_BIN = os.path.join(JDK8_HOME, "bin", "java")

if sys.platform.startswith("linux"):
    GCC_ENV = {"LD_LIBRARY_PATH": os.path.join(DIR, "work/gcc-inst/lib64")}
elif sys.platform.startswith("openbsd"):
    GCC_ENV = {"LD_LIBRARY_PATH": os.path.join(DIR, "work/gcc-inst/lib")}
else:
    raise NotImplementedError("unknown platform")

HEAP_LIMIT = 2097152  # 2GiB
STACK_LIMIT = 8192  # 8 MiB

# Variant name -> EntryPoint
VARIANTS = {
    "default-c": EntryPoint("bench.so", subdir="c"),
    "default-java": EntryPoint("KrunEntry", subdir="java"),
    "default-lua": EntryPoint("bench.lua", subdir="lua"),
    "default-python": EntryPoint("bench.py", subdir="python"),
    "default-php": EntryPoint("bench.php", subdir="php"),
    "default-ruby": EntryPoint("bench.rb", subdir="ruby"),
    "default-javascript": EntryPoint("bench.js", subdir="javascript"),
}

ITERATIONS_ALL_VMS = 2000

VMS = {
        'C': {
		'vm_def': NativeCodeVMDef(env=GCC_ENV),
		'variants': ['default-c'],
		'n_iterations': ITERATIONS_ALL_VMS,

        },
	'PyPy': {
		'vm_def': PyPyVMDef('work/pypy/pypy/goal/pypy-c',
                      env=GCC_ENV),
		'variants': ['default-python'],
		'n_iterations': ITERATIONS_ALL_VMS,
	},
	'Hotspot': {
		'vm_def': JavaVMDef(JDK8_BIN, env=GCC_ENV),
		'variants': ['default-java'],
		'n_iterations': ITERATIONS_ALL_VMS,
	},
	'LuaJIT': {
		'vm_def': LuaVMDef('work/luajit/src/luajit', env=GCC_ENV),
		'variants': ['default-lua'],
		'n_iterations': ITERATIONS_ALL_VMS,
	},
	'V8': {
		'vm_def': V8VMDef('work/v8/out/native/d8', env=GCC_ENV),
		'variants': ['default-javascript'],
		'n_iterations': ITERATIONS_ALL_VMS,
	},
	'CPython': {
		'vm_def': PythonVMDef('work/cpython-inst/bin/python',
                        env=GCC_ENV),
		'variants': ['default-python'],
		'n_iterations': ITERATIONS_ALL_VMS,
	}
}

if not sys.platform.startswith("openbsd"):
    # The following VMs do not run on OpenBSD.
    VMS.update({
        'Graal': {
            'vm_def': GraalVMDef('work/graal', 'work/mx/mx',
                                 java_home=find_internal_jvmci_java_home('work/jvmci/'),
                                 env=GCC_ENV),
            'variants': ['default-java'],
            'n_iterations': ITERATIONS_ALL_VMS,
        },
        'HHVM': {
            'vm_def': PHPVMDef('work/hhvm/hphp/hhvm/php', env=GCC_ENV),
            'variants': ['default-php'],
            'n_iterations': ITERATIONS_ALL_VMS,
        },
        'JRubyTruffle' : {
            'vm_def': JRubyTruffleVMDef('work/jruby/bin/jruby',
                                        java_path=find_internal_jvmci_java_bin('work/jvmci/'),
                                        env=GCC_ENV),
            'variants': ['default-ruby'],
            'n_iterations': ITERATIONS_ALL_VMS,
        },
    })


BENCHMARKS = {
    'binarytrees': 25,
    'richards': 500,
    'spectralnorm': 3,
    'nbody': 15,
    'fasta': 100,
    'fannkuch_redux': 200,
}

# list of "bench:vm:variant"
SKIP=[
    # Uncomment to skip whole VMs
    #
    #"*:PyPy:*",
    #"*:CPython:*",
    #"*:Hotspot:*",
    #"*:Graal:*",
    #"*:LuaJIT:*",
    #"*:HHVM:*",
    #"*:JRubyTruffle:*",
    #"*:V8:*",
    #"*:C:*",

    # XXX: This benchmark is slow *and* crashes
    "fasta:JRubyTruffle:default-ruby",
]

N_EXECUTIONS = 10  # Number of fresh processes.

if sys.platform.startswith("linux"):
    PRE_EXECUTION_CMDS = [
        "sudo service cron stop",
        "sudo service atd stop",
        "sudo service postfix stop",
    ]

    POST_EXECUTION_CMDS = [
        "sudo service cron start || true",
        "sudo service atd start || true",
        "sudo service postfix start || true",
    ]
elif sys.platform.startswith("openbsd"):
    PRE_EXECUTION_CMDS = [
        "sudo /etc/rc.d/cron stop",
        "sudo /etc/rc.d/smtpd stop",
        "sudo /etc/rc.d/pflogd stop",
    ]

    POST_EXECUTION_CMDS = [
        "sudo /etc/rc.d/cron start || true",
        "sudo /etc/rc.d/smtpd start || true",
        "sudo /etc/rc.d/pflogd start || true",
    ]
else:
    assert False


# Copy off results after each execution -- soft-dev specific!
#
# We allow failure, otherwise Krun will halt the experiment if (e.g.) the
# SSH server hostname is temporarily unavailable.
HOSTNAME = platform.node().split(".")[0]
SCP_CMD = ("tar czf - ${KRUN_RESULTS_FILE} ${KRUN_LOG_FILE} | "
           "ssh -i id_rsa " "vext01@bencher2.soft-dev.org "
           "'cat > research/krun_results/%s.tgz'" % HOSTNAME)
POST_EXECUTION_CMDS.append(
    "%s || ( sleep 2; %s ) || true " % (SCP_CMD, SCP_CMD)
)
